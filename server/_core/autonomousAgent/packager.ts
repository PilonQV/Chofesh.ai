/**
 * Packager - Bundles execution results into deliverable packages
 * 
 * This module takes the outputs from the executor and packages them
 * into immediately usable deliverables (ZIP files, deployment packages, etc.)
 */

import archiver from 'archiver';
import { Readable } from 'stream';
import { ExecutionContext } from './executor';
import { TaskPlan } from './taskPlanner';

// ============================================================================
// TYPES
// ============================================================================

export interface PackageResult {
  type: 'zip' | 'url' | 'document';
  filename?: string;
  buffer?: Buffer;
  url?: string;
  size?: number;
  files?: string[];
  readme?: string;
}

// ============================================================================
// PACKAGER
// ============================================================================

/**
 * Package execution results into a deliverable
 */
export async function packageResults(
  plan: TaskPlan,
  context: ExecutionContext
): Promise<PackageResult> {
  console.log('[Packager] Packaging results for:', plan.goal);
  
  switch (plan.category) {
    case 'website':
      return await packageWebsite(plan, context);
    
    case 'crm':
      return await packageCRM(plan, context);
    
    case 'campaign':
      return await packageCampaign(plan, context);
    
    case 'document':
      return await packageDocument(plan, context);
    
    default:
      return await packageGeneral(plan, context);
  }
}

/**
 * Package website files into a ZIP
 */
async function packageWebsite(plan: TaskPlan, context: ExecutionContext): Promise<PackageResult> {
  // Create README
  const readme = `# ${plan.goal}

## Quick Start

1. Extract this ZIP file
2. Open \`index.html\` in your browser to preview
3. Upload all files to your web hosting provider

## Files Included

${Array.from(context.files.keys()).map(f => `- ${f}`).join('\n')}

## Deployment Options

### Option 1: Static Hosting (Recommended)
- Upload to Vercel, Netlify, or GitHub Pages
- Free hosting with automatic HTTPS

### Option 2: Traditional Hosting
- Upload via FTP to your web host
- Point your domain to the hosting directory

### Option 3: Local Testing
- Open \`index.html\` directly in your browser
- Use a local server for best results: \`python3 -m http.server 8000\`

## Customization

- Edit \`index.html\` for content changes
- Modify \`styles.css\` for styling
- Update \`script.js\` for functionality

## Support

For questions or issues, refer to the documentation or contact support.

---

Generated by Chofesh.ai Autonomous Agent
${new Date().toISOString()}
`;

  // Add README to files
  context.files.set('README.md', Buffer.from(readme, 'utf-8'));
  
  // Create deployment guide
  const deployGuide = `# Deployment Guide

## Vercel (Recommended)

1. Install Vercel CLI: \`npm install -g vercel\`
2. Run: \`vercel\`
3. Follow the prompts
4. Your site will be live at: \`https://your-project.vercel.app\`

## Netlify

1. Drag and drop this folder to https://app.netlify.com/drop
2. Your site will be live instantly

## GitHub Pages

1. Create a new GitHub repository
2. Upload all files
3. Go to Settings → Pages
4. Select main branch as source
5. Your site will be live at: \`https://username.github.io/repo-name\`

## Traditional Hosting (cPanel, FTP)

1. Connect to your hosting via FTP
2. Upload all files to \`public_html\` or \`www\` directory
3. Access your site at your domain
`;

  context.files.set('DEPLOYMENT.md', Buffer.from(deployGuide, 'utf-8'));
  
  // Create ZIP
  const zipBuffer = await createZIP(context.files, 'website');
  
  return {
    type: 'zip',
    filename: 'website.zip',
    buffer: zipBuffer,
    size: zipBuffer.length,
    files: Array.from(context.files.keys()),
    readme,
  };
}

/**
 * Package CRM files into a ZIP
 */
async function packageCRM(plan: TaskPlan, context: ExecutionContext): Promise<PackageResult> {
  const readme = `# ${plan.goal}

## Quick Start

1. Extract this ZIP file
2. Install dependencies: \`npm install\`
3. Set up database: \`npm run db:setup\`
4. Start development server: \`npm run dev\`
5. Open http://localhost:3000

## Project Structure

\`\`\`
/
├── backend/          # API server (Express.js)
├── frontend/         # Admin dashboard (React)
├── database/         # Schema and migrations
├── docs/             # Documentation
└── README.md         # This file
\`\`\`

## Environment Variables

Create a \`.env\` file with:

\`\`\`
DATABASE_URL=postgresql://user:password@localhost:5432/crm
JWT_SECRET=your-secret-key
PORT=3000
\`\`\`

## Features

- Contact management
- Deal pipeline
- Task tracking
- User authentication
- API documentation

## Deployment

See DEPLOYMENT.md for production deployment instructions.

---

Generated by Chofesh.ai Autonomous Agent
${new Date().toISOString()}
`;

  context.files.set('README.md', Buffer.from(readme, 'utf-8'));
  
  // Add package.json
  const packageJson = {
    name: 'crm-system',
    version: '1.0.0',
    scripts: {
      'dev': 'concurrently "npm run dev:backend" "npm run dev:frontend"',
      'dev:backend': 'cd backend && npm run dev',
      'dev:frontend': 'cd frontend && npm run dev',
      'db:setup': 'cd database && npm run migrate',
      'build': 'npm run build:backend && npm run build:frontend',
    },
    dependencies: {
      'express': '^4.18.2',
      'react': '^18.2.0',
      'pg': '^8.11.0',
    },
  };
  
  context.files.set('package.json', Buffer.from(JSON.stringify(packageJson, null, 2), 'utf-8'));
  
  const zipBuffer = await createZIP(context.files, 'crm');
  
  return {
    type: 'zip',
    filename: 'crm-system.zip',
    buffer: zipBuffer,
    size: zipBuffer.length,
    files: Array.from(context.files.keys()),
    readme,
  };
}

/**
 * Package campaign files into a ZIP
 */
async function packageCampaign(plan: TaskPlan, context: ExecutionContext): Promise<PackageResult> {
  const readme = `# ${plan.goal}

## Campaign Overview

This package contains everything you need to launch your marketing campaign.

## Contents

1. **Strategy Document** - Campaign goals, target audience, messaging
2. **Creative Assets** - Images, graphics, and visual content
3. **Copy** - Headlines, body copy, CTAs for all channels
4. **Content Calendar** - Posting schedule and timeline
5. **Performance Tracking** - KPIs and analytics setup

## Quick Start

1. Review the strategy document
2. Approve creative assets
3. Schedule content using the calendar
4. Set up tracking and analytics
5. Launch campaign

## Files Included

${Array.from(context.files.keys()).map(f => `- ${f}`).join('\n')}

## Next Steps

1. Review all materials with your team
2. Make any necessary adjustments
3. Schedule posts in your social media management tool
4. Launch campaign on the scheduled date
5. Monitor performance daily

---

Generated by Chofesh.ai Autonomous Agent
${new Date().toISOString()}
`;

  context.files.set('README.md', Buffer.from(readme, 'utf-8'));
  
  const zipBuffer = await createZIP(context.files, 'campaign');
  
  return {
    type: 'zip',
    filename: 'marketing-campaign.zip',
    buffer: zipBuffer,
    size: zipBuffer.length,
    files: Array.from(context.files.keys()),
    readme,
  };
}

/**
 * Package document into a single file
 */
async function packageDocument(plan: TaskPlan, context: ExecutionContext): Promise<PackageResult> {
  // For documents, return the main file directly
  const mainFile = context.files.get('document.md') || context.files.get('document.pdf');
  
  if (mainFile) {
    return {
      type: 'document',
      filename: 'document.pdf',
      buffer: mainFile,
      size: mainFile.length,
    };
  }
  
  // Fallback to ZIP if multiple files
  const zipBuffer = await createZIP(context.files, 'document');
  
  return {
    type: 'zip',
    filename: 'document.zip',
    buffer: zipBuffer,
    size: zipBuffer.length,
    files: Array.from(context.files.keys()),
  };
}

/**
 * Package general results into a ZIP
 */
async function packageGeneral(plan: TaskPlan, context: ExecutionContext): Promise<PackageResult> {
  const readme = `# ${plan.goal}

## Results

This package contains the results of your request.

## Files Included

${Array.from(context.files.keys()).map(f => `- ${f}`).join('\n')}

---

Generated by Chofesh.ai Autonomous Agent
${new Date().toISOString()}
`;

  context.files.set('README.md', Buffer.from(readme, 'utf-8'));
  
  const zipBuffer = await createZIP(context.files, 'results');
  
  return {
    type: 'zip',
    filename: 'results.zip',
    buffer: zipBuffer,
    size: zipBuffer.length,
    files: Array.from(context.files.keys()),
    readme,
  };
}

/**
 * Create a ZIP file from a map of files
 */
async function createZIP(files: Map<string, Buffer>, baseName: string): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const archive = archiver('zip', {
      zlib: { level: 9 }, // Maximum compression
    });
    
    const chunks: Buffer[] = [];
    
    archive.on('data', (chunk: Buffer) => chunks.push(chunk));
    archive.on('end', () => resolve(Buffer.concat(chunks)));
    archive.on('error', reject);
    
    // Add all files to the archive
    for (const [filename, buffer] of files.entries()) {
      archive.append(buffer, { name: filename });
    }
    
    archive.finalize();
  });
}
